"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Constants_1 = require("./util/Constants");
const Atom_1 = require("./structures/Atom");
const Util_1 = require("./util/Util");
const float64Array = new Float64Array(1);
const uInt8Float64Array = new Uint8Array(float64Array.buffer);
class Packer {
    constructor(data) {
        this._offset = 0;
        this._buffer = new Uint8Array(16);
        this._data = data;
    }
    process() {
        this.write8(Constants_1.ETF_VERSION);
        this.pack(this._data);
        const temp = this._buffer.subarray(0, this._offset);
        this._data = null;
        this._offset = 0;
        this._buffer = null;
        return temp;
    }
    pack(value) {
        if (value === null || value === undefined) {
            return this.writeAtom('nil');
        }
        const typeofValue = typeof value;
        switch (typeofValue) {
            case 'bigint': return this.writeBigInt(value);
            case 'boolean': return this.writeAtom(value ? 'true' : 'false');
            case 'number': return this.writeNumber(value);
            case 'string': return this.writeString(value);
            case 'object': {
                if (value instanceof Atom_1.AtomClass)
                    return this.writeAtom(value.name);
                if (Array.isArray(value) || value instanceof Set)
                    return this.writeArray(value);
                if (value instanceof Map)
                    return this.writeMap(value);
                return this.writeMap(value);
            }
            // TODO: Symbols and functions?
            default: throw new Error(`Could not parse primitive type "${typeofValue}".`);
        }
    }
    writeAtom(atom) {
        if (atom.length > 255)
            throw new Error('Atom is too large!');
        const encoded = Packer._textEncoder.encode(atom);
        const isAscii = encoded.every(byte => byte < 0x80);
        if (isAscii) {
            this.write8(Constants_1.Tokens.ATOM_EXT);
        }
        else {
            this.write8(Constants_1.Tokens.ATOM_UTF8_EXT);
        }
        this.write16(encoded.length);
        this.write(encoded);
    }
    writeNil() {
        this.write8(Constants_1.Tokens.NIL_EXT);
    }
    writeNumber(value) {
        if (!Number.isFinite(value))
            throw new Error(`"${value}" is not a finite number.`);
        if (value === (value | 0)) {
            if (value >= 0 && value <= 255) {
                this.write8(Constants_1.Tokens.SMALL_INTEGER_EXT);
                this.write8(value);
            }
            else {
                this.write8(Constants_1.Tokens.INTEGER_EXT);
                this.write32(value);
            }
        }
        else {
            this.write8(Constants_1.Tokens.NEW_FLOAT_EXT);
            this.writeF64(value);
        }
    }
    writeBigInt(value) {
        this.write8(Constants_1.Tokens.LARGE_BIG_EXT);
        const byteCountIndex = this._offset;
        this.ensureAlloc(4);
        this._offset += 4;
        const sign = value > 0n ? 0 : 1;
        this.write8(sign);
        let byteCount = 0;
        let b = sign === 1 ? -value : value;
        while (b > 0) {
            byteCount += 1;
            this.write8(Number(b & 0xffn));
            b >>= 8n;
        }
        this.write32At(byteCount, byteCountIndex);
    }
    writeString(value) {
        this.write8(Constants_1.Tokens.BINARY_EXT);
        const encoded = Packer._textEncoder.encode(value);
        this.write32(encoded.length);
        this.write(encoded);
    }
    writeArray(array) {
        const length = Array.isArray(array) ? array.length : array.size;
        if (length === 0)
            return this.writeNil();
        this.write8(Constants_1.Tokens.LIST_EXT);
        this.write32(length);
        for (const value of array)
            this.pack(value);
        this.writeNil();
    }
    writeMap(value) {
        const entries = value instanceof Map ? [...value.entries()] : Object.entries(value);
        this.write8(Constants_1.Tokens.MAP_EXT);
        this.write32(entries.length);
        for (const [key, value] of entries) {
            // Maps can have full structures as the key
            const atomName = key instanceof Atom_1.AtomClass ? key.name : /Atom\((?<atomName>.+)\)/.exec(key.toString());
            if (atomName) {
                this.writeAtom(typeof atomName === 'string' ? atomName : atomName.groups.atomName);
            }
            else {
                this.pack(key);
            }
            this.pack(value);
        }
    }
    write(value) {
        this.ensureAlloc(value.byteLength);
        this._buffer.set(value, this._offset);
        this._offset += value.byteLength;
    }
    write8(value) {
        this.ensureAlloc(1);
        this._buffer[this._offset++] = value;
    }
    write16(value) {
        this.ensureAlloc(2);
        this.write16At(value, this._offset);
        this._offset += 2;
    }
    write16At(value, offset) {
        this._buffer[offset + 1] = value;
        value >>>= 8;
        this._buffer[offset] = value;
    }
    write32(value) {
        this.ensureAlloc(4);
        this.write32At(value, this._offset);
        this._offset += 4;
    }
    write32At(value, offset) {
        this._buffer[offset + 3] = value;
        value >>>= 8;
        this._buffer[offset + 2] = value;
        value >>>= 8;
        this._buffer[offset + 1] = value;
        value >>>= 8;
        this._buffer[offset] = value;
    }
    writeF64(value) {
        float64Array[0] = value;
        this.write(uInt8Float64Array);
    }
    ensureAlloc(amount) {
        this.expandBuffer(this._offset + amount);
    }
    expandBuffer(length) {
        if (this._buffer.length < length) {
            const old = this._buffer;
            this._buffer = new Uint8Array(Math.pow(2, Math.ceil(Math.log2(length))));
            this._buffer.set(old);
        }
    }
}
Packer._textEncoder = new Util_1.TE();
exports.Packer = Packer;
