// Generated by dts-bundle v0.7.3

export enum CompressionType {
    NONE = 0,
    FIXED = 1,
    DYNAMIC = 2,
    RESERVED = 3
}
export class Lz77Match {
    length: number;
    backwardDistance: number;
    constructor(length: number, backwardDistance: number);
    static get LengthCodeTable(): any[] | Uint32Array;
    getDistanceCode_(dist: number): any;
    toLz77Array(): any[];
}
export class RawDeflate {
    compressionType: CompressionType;
    lazy: number;
    freqsLitLen: Array<any> | Uint32Array;
    freqsDist: Array<any> | Uint32Array;
    input: Array<number> | Uint8Array;
    output: Array<number> | Uint8Array;
    op: number;
    length: number;
    backwardDistance: number;
    static Lz77MaxLength: number;
    static WindowSize: number;
    static MaxCodeLength: number;
    static HUFMAX: number;
    static Lz77MinLength: number;
    constructor(input: Array<number> | Uint8Array, opt_params?: any);
    static get FixedHuffmanTable(): any[];
    compress(): number[] | Uint8Array;
    makeNocompressBlock(blockArray: Array<number> | Uint8Array, isFinalBlock: boolean): number[] | Uint8Array;
    makeFixedHuffmanBlock(blockArray: Array<number> | Uint8Array, isFinalBlock: boolean): any;
    makeDynamicHuffmanBlock(blockArray: Array<number> | Uint8Array, isFinalBlock: boolean): any;
    dynamicHuffman(dataArray: Array<number> | Uint16Array, litLen: any[], dist: any[], stream: any): any;
    fixedHuffman(dataArray: Array<number> | Uint16Array, stream: BitStream): BitStream;
    lz77(dataArray: Array<number> | Uint8Array): number[] | Uint16Array;
    searchLongestMatch_(data: any, position: number, matchList: Array<number>): Lz77Match;
    getTreeSymbols_(hlit: number, litlenLengths: Array<number> | Uint8Array, hdist: number, distLengths: Array<number> | Uint8Array): {
        codes: any[] | Uint32Array;
        freqs: any[] | Uint8Array;
    };
    getLengths_(freqs: Array<number> | Uint8Array | Uint32Array, limit: number): any[] | Uint8Array;
    reversePackageMerge_(freqs: Array<number> | Uint32Array, symbols: number, limit: number): any[] | Uint8Array;
    getCodesFromLengths_(lengths: Uint8Array | Array<number>): any[] | Uint16Array;
}

export enum rStatus {
    INITIALIZED = 0,
    BLOCK_HEADER_START = 1,
    BLOCK_HEADER_END = 2,
    BLOCK_BODY_START = 3,
    BLOCK_BODY_END = 4,
    DECODE_BLOCK_START = 5,
    DECODE_BLOCK_END = 6
}
export enum rBlockType {
    UNCOMPRESSED = 0,
    FIXED = 1,
    DYNAMIC = 2
}
export class RawInflateStream {
    static Status: typeof rStatus;
    static BlockType: typeof rBlockType;
    ip: number;
    output: Array<number> | Uint8Array;
    static MaxBackwardLength: number;
    static MaxCopyLength: number;
    static Order: number[] | Uint16Array;
    static LengthCodeTable: number[] | Uint16Array;
    static LengthExtraTable: number[] | Uint8Array;
    static DistCodeTable: number[] | Uint16Array;
    static DistExtraTable: number[] | Uint8Array;
    static FixedLiteralLengthTable: any[];
    static FixedDistanceTable: any[];
    constructor(input: Uint8Array | Array<number>, ip?: number, opt_buffersize?: number);
    decompress(newInput: Uint8Array | Array<number>, ip: any): any;
    readBlockHeader(): number;
    readBits(length: number): any;
    readCodeByTable(table: Array<number> | Uint8Array): number;
    readUncompressedBlockHeader(): number;
    parseUncompressedBlock(): 0 | -1;
    parseFixedHuffmanBlock(): number;
    save_(): void;
    restore_(): void;
    parseDynamicHuffmanBlock(): 0 | -1;
    decodeHuffman(): number;
    expandBuffer(opt_param?: any): number[] | Uint8Array;
    concatBuffer(): any;
}

export enum rBufferType {
    BLOCK = 0,
    ADAPTIVE = 1
}
export class RawInflate {
    static ZLIB_RAW_INFLATE_BUFFER_SIZE: number;
    static buildHuffmanTable: typeof Huffman.buildHuffmanTable;
    static BufferType: typeof rBufferType;
    static MaxBackwardLength: number;
    static MaxCopyLength: number;
    currentLitlenTable: Array<number> | Uint16Array;
    static Order: number[] | Uint16Array;
    static LengthCodeTable: number[] | Uint16Array;
    static LengthExtraTable: number[] | Uint8Array;
    static DistCodeTable: number[] | Uint16Array;
    static DistExtraTable: number[] | Uint8Array;
    static FixedLiteralLengthTable: any[];
    static FixedDistanceTable: any[];
    buffer: Array<number> | Uint8Array;
    blocks: Array<(Array<number> | Uint8Array)>;
    bufferSize: number;
    totalpos: number;
    ip: any;
    bitsbuf: any;
    bitsbuflen: any;
    input: Array<number> | Uint8Array;
    output: Array<number> | Uint8Array;
    /** @type {!number} output buffer pointer. */
    op: number;
    /** @type {boolean} is final block flag. */
    bfinal: boolean;
    /** @type {Zlib.RawInflate.BufferType} buffer management. */
    bufferType: rBufferType;
    /** @type {boolean} resize flag for memory size optimization. */
    resize: boolean;
    constructor(input: Uint8Array | Array<number>, opt_params?: any);
    decompress(): number[] | Uint8Array;
    parseBlock(): void;
    readBits(length: number): any;
    readCodeByTable(table: Array<number> | Uint16Array | Uint8Array): number;
    parseUncompressedBlock(): void;
    parseFixedHuffmanBlock(): void;
    parseDynamicHuffmanBlock(): void;
    decodeHuffmanBlock(litlen: Array<number> | Uint16Array, dist: Array<number> | Uint8Array): void;
    decodeHuffmanAdaptive(litlen: Array<number> | Uint16Array, dist: Array<number> | Uint8Array): void;
    expandBufferBlock(): number[] | Uint8Array;
    expandBufferAdaptive(opt_param?: any): number[] | Uint8Array;
    concatBufferBlock(): number[] | Uint8Array;
    concatBufferDynamic(): number[] | Uint8Array;
}

export class BitStream {
    static DefaultBlockSize: number;
    static ReverseTable: Uint8Array | any[];
    constructor(buffer: Uint8Array | Array<any>, bufferPosition: number);
    expandBuffer(): any[] | Uint8Array;
    writeBits(number: number, n: number, reverse?: boolean): void;
    finish(): any;
}

/**
  * build huffman table from length list.
  * @param {!(Array.<number>|Uint8Array)} lengths length list.
  * @return {!Array} huffman table.
  */
export class Huffman {
    constructor();
    static buildHuffmanTable(lengths: Array<number> | Uint8Array): any[];
}

